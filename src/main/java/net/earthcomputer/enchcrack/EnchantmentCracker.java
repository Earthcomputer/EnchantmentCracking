package net.earthcomputer.enchcrack;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.function.Predicate;
import java.util.function.Supplier;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.resources.I18n;
import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentData;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.Enchantments;
import net.minecraft.init.Items;
import net.minecraft.inventory.ClickType;
import net.minecraft.inventory.ContainerEnchantment;
import net.minecraft.inventory.Slot;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.IStringSerializable;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.world.World;

public class EnchantmentCracker {

	/*
	 * The enchantment cracker works as follows:
	 * 
	 * First, crack the first few XP seeds. When you open an enchantment table GUI,
	 * the server gives you 12 bits of the 32-bit enchantment seed. Vanilla uses
	 * this masked version of the seed to generate the galactic alphabet text in the
	 * GUI. We use brute force to guess the other 20 bits, matching each possibility
	 * and what it would generate with certain things the server tells us, such as
	 * the enchantment hints. We can narrow down the possibilities to 1 after
	 * putting a few items into the enchantment table.
	 * 
	 * Second, we know that the above XP seeds are generated by calling the player
	 * entity's RNG's unbounded nextInt() method. This means that after a doing the
	 * above a few times, enchanting an item after each time, we have a few
	 * consecutive values of nextInt(). Each time an item is enchanted, we narrow
	 * down the possibilities of what the player RNG's state could be. The first
	 * value of nextInt() gives us 32 bits of its 48-bit internal state. Each time
	 * nextInt() is next called, we narrow down its internal state by brute force.
	 * It usually only takes two values of nextInt() to guess the internal state.
	 * 
	 * There's one small catch: for this to work, we have to know that the values of
	 * nextInt() are indeed consecutive. The first XP seed, if it's cracked, cannot
	 * be used as one of these values since it was generated an unknown length of
	 * time in the past, possibly even before a server restart - so we have to
	 * ignore that. More obviously, there are many, many other things which use the
	 * player's RNG and hence affect its internal state. We have to detect on the
	 * client side when one of these things is likely to be happening. This is only
	 * possible to do for certain if the server is running vanilla because some mod
	 * could use the player's RNG for some miscellaneous task.
	 * 
	 * Third, we can take advantage of the fact that generating XP seeds is not the
	 * only thing that the player RNG does, to manipulate the RNG to produce an XP
	 * seed which we want. The /cenchant command, which calls the
	 * manipulateEnchantments method of this class, does this. We change the state
	 * of the player RNG in a predictable way by throwing out items of the player's
	 * inventory. Each time the player throws out an item, rand.nextFloat() gets
	 * called 4 times to determine the velocity of the item which is thrown out. If
	 * we throw out n items before we then do a dummy enchantment to generate our
	 * new enchantment seed, then we can change n to change the enchantment seed. By
	 * simulating which XP seed each n (up to a limit) will generate, and which
	 * enchantments that XP seed will generate, we can filter out which enchantments
	 * we want and determine n.
	 */

	private static final Logger LOGGER = LogManager.getLogger("enchcracker");

	private static EnumCrackState crackState = EnumCrackState.UNCRACKED;

	// RNG CHECK
	/*
	 * The RNG check tries to detect client-side every single case where the
	 * player's RNG could be called server side. The only known case (other than a
	 * modded server) where this doesn't work is currently when a server operator
	 * other than you gives you an item with the /give command. This is deemed
	 * undetectable on the client-side.
	 */

	private static int expectedThrows = 0;

	public static void frostWalkerCheck(EntityPlayer player, int level) {
		World world = player.world;
		BlockPos pos = new BlockPos(player);

		// see EnchantmentFrostWalker.freezeNearby

		if (player.onGround) {
			float radius = (float) Math.min(16, 2 + level);
			BlockPos.MutableBlockPos posAboveWater = new BlockPos.MutableBlockPos(0, 0, 0);

			for (BlockPos.MutableBlockPos waterPos : BlockPos.getAllInBoxMutable(pos.add(-radius, -1, -radius),
					pos.add(radius, -1, radius))) {
				if (waterPos.distanceSqToCenter(player.posX, player.posY, player.posZ) <= radius * radius) {
					posAboveWater.setPos(waterPos.getX(), waterPos.getY() + 1, waterPos.getZ());
					IBlockState stateAboveWater = world.getBlockState(posAboveWater);

					if (stateAboveWater.getMaterial() == Material.AIR) {
						IBlockState stateAtWater = world.getBlockState(waterPos);

						if (stateAtWater.getBlock() == Blocks.FROSTED_ICE) {
							resetCracker("frostWalker");
							return;
						}
					}
				}
			}
		}
	}

	public static void dropItemCheck() {
		if (expectedThrows > 0)
			expectedThrows--;
		else
			resetCracker("dropItem");
	}

	public static void toolDamageCheck(ItemStack stack, int damage) {
		if (EnchantmentHelper.getEnchantments(stack).containsKey(Enchantments.UNBREAKING)) {
			resetCracker("unbreaking");
		} else if (stack.getItemDamage() + damage > stack.getMaxDamage() + 1 && stack.getItem() != Items.ELYTRA) {
			resetCracker("itemBreak");
		}
	}

	public static void resetCracker(String reason) {
		if (crackState != EnumCrackState.UNCRACKED) {
			Minecraft.getMinecraft().ingameGUI.getChatGUI().printChatMessage(new TextComponentString(
					TextFormatting.RED + I18n.format("enchCrack.reset", I18n.format("enchCrack.reset." + reason))));
		}
		resetCracker();
	}

	// RENDERING
	/*
	 * This section is in charge of rendering the overlay on the enchantment GUI
	 */

	public static void drawEnchantmentGUIOverlay(GuiScreen gui, List<EnchantmentData> wanted,
			List<EnchantmentData> unwanted) {
		List<String> lines = new ArrayList<>();

		lines.add(I18n.format("enchCrack.state", I18n.format("enchCrack.state." + crackState.getName())));

		lines.add("");

		if (crackState == EnumCrackState.CRACKED_ENCH_SEED) {
			lines.add(I18n.format("enchCrack.xpSeed.one", possibleXPSeeds.iterator().next()));
		} else if (crackState == EnumCrackState.CRACKING_ENCH_SEED) {
			lines.add(I18n.format("enchCrack.xpSeed.many", possibleXPSeeds.size()));
		} else if (crackState == EnumCrackState.CRACKING && !possiblePlayerRandSeeds.isEmpty()) {
			lines.add(I18n.format("enchCrack.playerRNGSeed.many", possiblePlayerRandSeeds.size()));
		}

		lines.add("");

		if (crackState == EnumCrackState.CRACKED || crackState == EnumCrackState.CRACKED_ENCH_SEED
				|| crackState == EnumCrackState.ENCHANT_MANIPULATING) {
			lines.add(I18n.format("enchCrack.enchantments"));
		} else {
			lines.add(I18n.format("enchCrack.clues"));
		}

		for (int slot = 0; slot < 3; slot++) {
			lines.add(I18n.format("enchCrack.slot", slot + 1));
			List<EnchantmentData> enchs = getEnchantmentsInTable(slot);
			if (enchs != null) {
				for (EnchantmentData ench : enchs) {
					lines.add("   " + ench.enchantment.getTranslatedName(ench.enchantmentLevel));
				}
			}
		}

		FontRenderer fontRenderer = Minecraft.getMinecraft().fontRenderer;
		int y = 0;
		for (String line : lines) {
			fontRenderer.drawString(line, 0, y, 0xffffff);
			y += fontRenderer.FONT_HEIGHT;
		}

		y = gui.height - (wanted.size() + unwanted.size()) * fontRenderer.FONT_HEIGHT;
		for (EnchantmentData ench : wanted) {
			fontRenderer.drawString(ench.enchantment.getTranslatedName(ench.enchantmentLevel), 0, y, 0x00ff00);
			y += fontRenderer.FONT_HEIGHT;
		}
		for (EnchantmentData ench : unwanted) {
			fontRenderer.drawString(ench.enchantment.getTranslatedName(ench.enchantmentLevel), 0, y, 0xff0000);
			y += fontRenderer.FONT_HEIGHT;
		}
	}

	// LOGIC
	/*
	 * This section is in charge of the logic of the cracking
	 */

	private static final long MULTIPLIER = 0x5deece66dL;
	private static final long ADDEND = 0xbL;
	private static final long MASK = (1L << 48) - 1;

	private static Set<Integer> possibleXPSeeds = new HashSet<>(1 << 20);
	private static boolean onFirstXPSeed = true;
	private static Set<Long> possiblePlayerRandSeeds = new HashSet<>(1 << 16);
	private static Random playerRand = new Random();
	private static boolean doneEnchantment = false;

	public static boolean isCracked() {
		return crackState == EnumCrackState.CRACKED;
	}

	public static void resetCracker() {
		crackState = EnumCrackState.UNCRACKED;
		onFirstXPSeed = true;
		possibleXPSeeds.clear();
		possiblePlayerRandSeeds.clear();
	}

	private static void prepareForNextEnchantmentSeedCrack(int serverReportedXPSeed) {
		serverReportedXPSeed &= 0x0000fff0;
		for (int highBits = 0; highBits < 65536; highBits++) {
			for (int low4Bits = 0; low4Bits < 16; low4Bits++) {
				possibleXPSeeds.add((highBits << 16) | serverReportedXPSeed | low4Bits);
			}
		}
	}

	public static void addEnchantmentSeedInfo(World world, BlockPos tablePos, ContainerEnchantment container) {
		if (crackState == EnumCrackState.CRACKED_ENCH_SEED || crackState == EnumCrackState.CRACKED
				|| crackState == EnumCrackState.ENCHANT_MANIPULATING) {
			return;
		}

		ItemStack itemToEnchant = container.tableInventory.getStackInSlot(0);
		if (itemToEnchant.isEmpty() || !itemToEnchant.isItemEnchantable()) {
			return;
		}

		if (crackState == EnumCrackState.UNCRACKED || crackState == EnumCrackState.CRACKING) {
			crackState = EnumCrackState.CRACKING_ENCH_SEED;
			prepareForNextEnchantmentSeedCrack(container.xpSeed);
		}
		int power = getEnchantPower(world, tablePos);

		Random rand = new Random();
		int[] actualEnchantLevels = container.enchantLevels;
		int[] actualEnchantmentClues = container.enchantClue;
		int[] actualLevelClues = container.worldClue;

		// brute force the possible seeds
		Iterator<Integer> xpSeedItr = possibleXPSeeds.iterator();
		seedLoop: while (xpSeedItr.hasNext()) {
			int xpSeed = xpSeedItr.next();
			rand.setSeed(xpSeed);

			// check enchantment levels match
			for (int slot = 0; slot < 3; slot++) {
				int level = EnchantmentHelper.calcItemStackEnchantability(rand, slot, power, itemToEnchant);
				if (level < slot + 1) {
					level = 0;
				}
				if (level != actualEnchantLevels[slot]) {
					xpSeedItr.remove();
					continue seedLoop;
				}
			}

			// generate enchantment clues and see if they match
			for (int slot = 0; slot < 3; slot++) {
				if (actualEnchantLevels[slot] > 0) {
					List<EnchantmentData> enchantments = getEnchantmentList(rand, xpSeed, itemToEnchant, slot,
							actualEnchantLevels[slot]);
					if (enchantments == null || enchantments.isEmpty()) {
						// check that there is indeed no enchantment clue
						if (actualEnchantmentClues[slot] != -1 || actualLevelClues[slot] != -1) {
							xpSeedItr.remove();
							continue seedLoop;
						}
					} else {
						// check the right enchantment clue was generated
						EnchantmentData clue = enchantments.get(rand.nextInt(enchantments.size()));
						if (Enchantment.getEnchantmentID(clue.enchantment) != actualEnchantmentClues[slot]
								|| clue.enchantmentLevel != actualLevelClues[slot]) {
							xpSeedItr.remove();
							continue seedLoop;
						}
					}
				}
			}
		}

		// test the outcome, see if we need to change state
		if (possibleXPSeeds.size() == 0) {
			crackState = EnumCrackState.INVALID;
			LOGGER.warn(
					"Invalid enchantment seed information. Has the server got unknown mods, is there a desync, or is the client just bugged?");
		} else if (possibleXPSeeds.size() == 1) {
			crackState = EnumCrackState.CRACKED_ENCH_SEED;
			if (!onFirstXPSeed) {
				addPlayerRNGInfo(possibleXPSeeds.iterator().next());
			}
			onFirstXPSeed = false;
		}
	}

	private static void addPlayerRNGInfo(int enchantmentSeed) {
		if (crackState == EnumCrackState.CRACKED || crackState == EnumCrackState.ENCHANT_MANIPULATING) {
			return;
		}

		long newSeedHigh = ((long) enchantmentSeed << 16) & 0x0000_ffff_ffff_0000L;
		if (possiblePlayerRandSeeds.isEmpty() && crackState != EnumCrackState.INVALID) {
			// add initial 2^16 possibilities
			for (int lowBits = 0; lowBits < 65536; lowBits++) {
				possiblePlayerRandSeeds.add(newSeedHigh | lowBits);
			}
		} else {
			// it's okay to allocate a new one, it will likely be small anyway
			Set<Long> newPlayerRandSeeds = new HashSet<>();
			// narrow down possibilities using brute force
			for (long oldSeed : possiblePlayerRandSeeds) {
				// this is what Random.nextInt() does internally
				long newSeed = (oldSeed * MULTIPLIER + ADDEND) & MASK;
				if ((newSeed & 0x0000_ffff_ffff_0000L) == newSeedHigh) {
					newPlayerRandSeeds.add(newSeed);
				}
			}
			// add the new seed, not the old one, since the state of the RNG has changed
			// server-side
			possiblePlayerRandSeeds.clear();
			possiblePlayerRandSeeds.addAll(newPlayerRandSeeds);

			// check the outcome, see if we need to change state
			if (possiblePlayerRandSeeds.size() == 0) {
				crackState = EnumCrackState.INVALID;
				LOGGER.warn(
						"Invalid player RNG information. Has the server got unknown mods, is there a desync, has an operator used /give, or is the client just bugged?");
			} else if (possiblePlayerRandSeeds.size() == 1) {
				crackState = EnumCrackState.CRACKED;
				playerRand.setSeed(possiblePlayerRandSeeds.iterator().next() ^ MULTIPLIER);
				possiblePlayerRandSeeds.clear();
			}
		}
	}

	public static void onEnchantedItem() {
		doneEnchantment = true;
		if (crackState == EnumCrackState.CRACKED || crackState == EnumCrackState.ENCHANT_MANIPULATING) {
			possibleXPSeeds.clear();
			possibleXPSeeds.add(playerRand.nextInt());
		} else if (crackState == EnumCrackState.CRACKED_ENCH_SEED) {
			possibleXPSeeds.clear();
			crackState = EnumCrackState.CRACKING;
		} else {
			resetCracker();
			onFirstXPSeed = false;
		}
	}

	// ENCHANTMENT MANIPULATION
	/*
	 * This section is involved in actually manipulating the enchantments and the XP
	 * seed
	 */

	private static List<Supplier<Boolean>> tasks = new ArrayList<>();
	private static int timeout = 0;

	private static EnchantManipulationStatus manipulateEnchantmentsSanityCheck(EntityPlayer player) {
		if (crackState != EnumCrackState.CRACKED && crackState != EnumCrackState.ENCHANT_MANIPULATING) {
			return EnchantManipulationStatus.NOT_CRACKED;
		} else if (!player.onGround) {
			return EnchantManipulationStatus.NOT_ON_GROUND;
		} else if (player.inventoryContainer.getInventory().stream().allMatch(ItemStack::isEmpty)) {
			return EnchantManipulationStatus.EMPTY_INVENTORY;
		} else {
			return EnchantManipulationStatus.OK;
		}
	}

	public static EnchantManipulationStatus manipulateEnchantments(Item item,
			Predicate<List<EnchantmentData>> enchantmentsPredicate) {
		EntityPlayerSP player = Minecraft.getMinecraft().player;

		EnchantManipulationStatus status = manipulateEnchantmentsSanityCheck(player);
		if (status != EnchantManipulationStatus.OK) {
			return status;
		}

		ItemStack stack = new ItemStack(item);
		long seed = Util.getRandomSeed(playerRand);
		// -2: not found; -1: no dummy enchantment needed; >= 0: number of times needed
		// to throw out item before dummy enchantment
		int timesNeeded = -2;
		int bookshelvesNeeded = 0;
		int slot = 0;
		int[] enchantLevels = new int[3];
		outerLoop: for (int i = -1; i < 10000; i++) {
			int xpSeed = (int) ((i == -1 ? seed : ((seed * MULTIPLIER + ADDEND) & MASK)) >>> 16);
			Random rand = new Random();
			for (bookshelvesNeeded = 0; bookshelvesNeeded <= 15; bookshelvesNeeded++) {
				rand.setSeed(xpSeed);
				for (slot = 0; slot < 3; slot++) {
					int level = EnchantmentHelper.calcItemStackEnchantability(rand, slot, bookshelvesNeeded, stack);
					if (level < slot + 1) {
						level = 0;
					}
					enchantLevels[slot] = level;
				}
				for (slot = 0; slot < 3; slot++) {
					List<EnchantmentData> enchantments = getEnchantmentList(rand, xpSeed, stack, slot,
							enchantLevels[slot]);
					if (enchantmentsPredicate.test(enchantments)) {
						timesNeeded = i;
						break outerLoop;
					}
				}
			}

			if (i != -1) {
				for (int j = 0; j < 4; j++) {
					seed = (seed * MULTIPLIER + ADDEND) & MASK;
				}
			}
		}
		if (timesNeeded == -2) {
			return EnchantManipulationStatus.IMPOSSIBLE;
		}

		crackState = EnumCrackState.ENCHANT_MANIPULATING;

		if (timesNeeded != -1) {
			if (timesNeeded != 0) {
				player.closeScreen();
				player.setLocationAndAngles(player.posX, player.posY, player.posZ, player.rotationYaw, 90);
				// sync rotation to server before we throw any items
				player.connection.sendPacket(new CPacketPlayer.Rotation(player.rotationYaw, 90, player.onGround));
				Minecraft.getMinecraft().ingameGUI.getChatGUI().printChatMessage(
						new TextComponentTranslation(I18n.format("enchCrack.insn.starting", timesNeeded)));
			}
			for (int i = 0; i < timesNeeded; i++) {
				// throw the item
				tasks.add(() -> {
					EnchantManipulationStatus st = manipulateEnchantmentsSanityCheck(player);
					if (st != EnchantManipulationStatus.OK) {
						if (st != EnchantManipulationStatus.EMPTY_INVENTORY) {
							player.sendMessage(new TextComponentString(
									TextFormatting.RED + I18n.format(st.getTranslation())));
							tasks.clear();
							timeout = 0;
							crackState = EnumCrackState.CRACKED;
						}
					}
					if (player.inventory.getItemStack().isEmpty()) {
						Slot matchingSlot = player.inventoryContainer.inventorySlots.stream().
								filter(s -> s.getStack().getCount() == s.getStack().getMaxStackSize()).findAny().orElse(null);
						if (matchingSlot == null) {
							return false;
						}
						Minecraft.getMinecraft().playerController.windowClick(player.inventoryContainer.windowId, matchingSlot.slotNumber, 0, ClickType.PICKUP, player);
					}
					if (player.inventory.getItemStack().isEmpty()) {
						return false;
					}
					expectedThrows++;
					for (int j = 0; j < 4; j++) {
						playerRand.nextInt();
					}
					Minecraft.getMinecraft().playerController.windowClick(player.inventoryContainer.windowId,
							-999, 1, ClickType.PICKUP, player);
					return true;
				});
			}
			// dummy enchantment
			tasks.add(() -> {
				doneEnchantment = false;
				player.sendMessage(new TextComponentTranslation("enchCrack.insn.dummy"));
				return true;
			});
			tasks.add(() -> {
				timeout = 0;
				crackState = EnumCrackState.CRACKED;
				return doneEnchantment;
			});
		}
		final int bookshelvesNeeded_f = bookshelvesNeeded;
		final int slot_f = slot;
		tasks.add(() -> {
			player.sendMessage(new TextComponentString(TextFormatting.BOLD + I18n.format("enchCrack.insn.ready")));
			player.sendMessage(new TextComponentTranslation("enchCrack.insn.bookshelves", bookshelvesNeeded_f));
			player.sendMessage(new TextComponentTranslation("enchCrack.insn.slot", slot_f + 1));
			return true;
		});

		return EnchantManipulationStatus.OK;
	}

	public static void onTick() {
		if (!tasks.isEmpty()) {
			Supplier<Boolean> task = tasks.get(0);
			if (task.get()) {
				timeout = 0;
				if (!tasks.isEmpty())
					tasks.remove(0);
			} else {
				timeout++;
				if (timeout > 100) {
					ITextComponent message = new TextComponentTranslation("enchCrack.timeout");
					message.getStyle().setColor(TextFormatting.RED);
					Minecraft.getMinecraft().ingameGUI.getChatGUI().printChatMessage(message);
					tasks.clear();
					timeout = 0;
					crackState = EnumCrackState.CRACKED;
				}
			}
		}
	}

	public static enum EnchantManipulationStatus {
		// @formatter:off
		OK("ok"), NOT_CRACKED("notCracked"), NOT_ON_GROUND("notOnGround"), EMPTY_INVENTORY(
				"emptyInventory"), IMPOSSIBLE("impossible");
		// @formatter:on

		private String translation;

		private EnchantManipulationStatus(String translation) {
			this.translation = translation;
		}

		public String getTranslation() {
			return "enchCrack.manipStatus." + translation;
		}
	}

	// MISCELLANEOUS HELPER METHODS & ENCHANTING SIMULATION

	private static int getEnchantPower(World world, BlockPos tablePos) {
		float power = 0;

		for (int dz = -1; dz <= 1; dz++) {
			for (int dx = -1; dx <= 1; dx++) {
				if ((dz != 0 || dx != 0) && world.isAirBlock(tablePos.add(dx, 0, dz))
						&& world.isAirBlock(tablePos.add(dx, 1, dz))) {
					power += getBlockPower(world, tablePos.add(dx * 2, 0, dz * 2));
					power += getBlockPower(world, tablePos.add(dx * 2, 1, dz * 2));
					if (dx != 0 && dz != 0) {
						power += getBlockPower(world, tablePos.add(dx * 2, 0, dz));
						power += getBlockPower(world, tablePos.add(dx * 2, 1, dz));
						power += getBlockPower(world, tablePos.add(dx, 0, dz * 2));
						power += getBlockPower(world, tablePos.add(dx, 1, dz * 2));
					}
				}
			}
		}

		return (int) power;
	}

	private static int getBlockPower(World world, BlockPos pos) {
		return world.getBlockState(pos).getBlock() == Blocks.BOOKSHELF ? 1 : 0;
	}

	private static List<EnchantmentData> getEnchantmentList(Random rand, int xpSeed, ItemStack stack, int enchantSlot,
			int level) {
		rand.setSeed(xpSeed + enchantSlot);
		List<EnchantmentData> list = EnchantmentHelper.buildEnchantmentList(rand, stack, level, false);

		if (stack.getItem() == Items.BOOK && list.size() > 1) {
			list.remove(rand.nextInt(list.size()));
		}

		return list;
	}

	// Same as above method, except does not assume the seed has been cracked. If it
	// hasn't returns the clue given by the server
	public static List<EnchantmentData> getEnchantmentsInTable(int slot) {
		if (!(Minecraft.getMinecraft().player.openContainer instanceof ContainerEnchantment))
			return Collections.emptyList();
		ContainerEnchantment enchContainer = (ContainerEnchantment) Minecraft.getMinecraft().player.openContainer;

		if (crackState != EnumCrackState.CRACKED_ENCH_SEED && crackState != EnumCrackState.CRACKED
				&& crackState != EnumCrackState.ENCHANT_MANIPULATING) {
			if (enchContainer.enchantClue[slot] == -1) {
				// if we haven't cracked it, and there's no clue, then we can't give any
				// information about the enchantment
				return null;
			} else {
				// return a list containing the clue
				return Collections.singletonList(
						new EnchantmentData(Enchantment.getEnchantmentByID(enchContainer.enchantClue[slot]),
								enchContainer.worldClue[slot]));
			}
		} else {
			// return the enchantments using our cracked seed
			Random rand = new Random();
			int xpSeed = possibleXPSeeds.iterator().next();
			ItemStack enchantingStack = enchContainer.tableInventory.getStackInSlot(0);
			int enchantLevels = enchContainer.enchantLevels[slot];
			return getEnchantmentList(rand, xpSeed, enchantingStack, slot, enchantLevels);
		}
	}

	public static enum EnumCrackState implements IStringSerializable {
		UNCRACKED("uncracked"), CRACKING_ENCH_SEED("crackingEnchSeed"), CRACKED_ENCH_SEED("crackedEnchSeed"), CRACKING(
				"cracking"), CRACKED("cracked"), ENCHANT_MANIPULATING("enchantManipulating"), INVALID("invalid");

		private String name;

		private EnumCrackState(String name) {
			this.name = name;
		}

		@Override
		public String getName() {
			return name;
		}
	}

}